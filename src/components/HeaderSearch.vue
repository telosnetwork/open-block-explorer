<script lang="ts">
import { defineComponent, ref, watch } from 'vue';
import { useRouter } from 'vue-router';
import { OptionsObj } from 'src/types';
import { api } from 'src/api';
import { isValidHex } from 'src/utils/stringValidator';
import { useQuasar } from 'quasar';

export default defineComponent({
  name: 'HeaderSearch',
  setup() {
    const router = useRouter();
    const $q = useQuasar();

    const inputValue = ref('');
    const options = ref<OptionsObj[]>([]);
    const isLoading = ref(false);

    watch(inputValue, async () => {
      isLoading.value = true;
      const queryValue = inputValue.value.toLowerCase();
      options.value = [];

      await Promise.all([
        searchAccounts(queryValue),
        searchProposals(queryValue),
        searchTransactions(queryValue)
      ]).then((results) => {
        options.value = ([] as OptionsObj[]).concat.apply([], results);
      });

      isLoading.value = false;
    });

    async function searchAccounts(value: string): Promise<OptionsObj[]> {
      try {
        const results = [] as OptionsObj[];
        if (value === '') {
          return results;
        }
        const request = {
          code: 'eosio',
          limit: 5,
          lower_bound: cleanSearchInput(value),
          table: 'userres',
          upper_bound: value.padEnd(12, 'z')
        };
        const accounts = await api.getTableByScope(request);

        if (accounts.length > 0) {
          results.push({
            label: 'Accounts',
            to: '',
            isHeader: true
          });

          // because the get table by scope for userres does not include eosio account
          if ('eosio'.includes(value)) {
            results.push({
              label: 'eosio',
              to: '/account/eosio',
              isHeader: false
            });
          }

          accounts.forEach((user) => {
            if (user.payer.includes(value)) {
              results.push({
                label: user.payer,
                to: `/account/${user.payer}`,
                isHeader: false
              });
            }
          });
        }
        return results;
      } catch (error) {
        return;
      }
    }

    async function searchProposals(value: string): Promise<OptionsObj[]> {
      try {
        const results = [] as OptionsObj[];
        if (value === '') {
          return results;
        }
        const { proposals } = await api.getProposals({
          proposal: value
        });
        if (proposals.length > 0) {
          results.push({
            label: 'Proposals',
            to: '',
            isHeader: true
          });

          proposals.forEach((item) => {
            results.push({
              label: item.proposal_name,
              to: `/proposal/${item.proposal_name}`,
              isHeader: false
            });
          });
        }
        return results;
      } catch (error) {
        return;
      }
    }

    function cleanSearchInput(value: string): string {
      // remove leading and trailing spaces and periods from search input for query
      return value.replace(/^[\s.]+|[\s.]+$/g, '');
    }

    async function searchTransactions(value: string): Promise<OptionsObj[]> {
      const results = [] as OptionsObj[];

      if (value.length !== 64 || value === '') {
        return results;
      }

      try {
        const transactions = await api.getTransaction(value);

        if (transactions?.actions) {
          results.push({
            label: 'Transactions',
            to: '',
            isHeader: true
          });

          results.push({
            label: value,
            to: `/transaction/${value}`,
            isHeader: false
          });
        }
        return results;
      } catch (error) {
        return;
      }
    }

    async function handleGoTo(path?: string) {
      if (!inputValue.value) {
        return;
      }

      // if clicked/selected from dropdown search results
      if (typeof path === 'string') {
        await router.push(path);
        router.go(0);
      }

      // transaction validation
      if (isValidHex(inputValue.value) && inputValue.value.length == 64) {
        await router.push({
          name: 'transaction',
          params: { transaction: inputValue.value }
        });
        router.go(0);

        // key validation
      } else if (
        (inputValue.value.length == 53 && inputValue.value.startsWith('EOS')) ||
        (inputValue.value.length == 57 && inputValue.value.startsWith('PUB_K1'))
      ) {
        await router.push({
          name: 'key',
          params: { key: inputValue.value }
        });
        router.go(0);

        // default to 'account'
      } else if (inputValue.value.length <= 13) {
        try {
          await api.getAccount(inputValue.value.toLowerCase());
          await router.push({
            name: 'account',
            params: {
              account: inputValue.value.toLowerCase()
            }
          });
          router.go(0);
          return;
        } catch (error) {
          $q.notify(`account ${inputValue.value} not found!`);
        }
      }
    }

    return {
      inputValue,
      options,
      isLoading,
      handleGoTo
    };
  }
});
</script>

<template lang="pug">
q-select(
  borderless
  dense
  filled
  use-input
  hide-selected
  fill-input
  hide-bottom-space
  input-style="color:white"
  color="white"
  :loading="isLoading"
  :model-value="inputValue"
  @input-value="(value: string) => inputValue = value"
  @keyup.enter="handleGoTo"
  :options="options"
  :option-disable="(item) => item.isHeader"
).search-input
  template(#prepend)
    q-icon(name="search" color="white" size="20px").rotate-90

  template(#no-option)
    q-item
      q-item-section.text-center
        q-item-label(v-if="isLoading") Searching...
        q-item-label(v-else) {{ inputValue ? 'Nothing found' : 'Search by accounts, keys, proposals and transactions' }}

  template(#option="scope")
    q-item-label(v-if="scope.opt.isHeader" header) {{ scope.opt.label }}
    q-item(v-else v-bind="scope.itemProps" exact @click="handleGoTo(scope.opt.to)" clickable)
      q-item-section
        q-item-label {{ scope.opt.label }}
</template>

<style lang="sass">
.search-input
  background: rgba(255, 255, 255, 0.05)
  border-radius: 4px

.search-input .q-select__dropdown-icon
  color: white
</style>
